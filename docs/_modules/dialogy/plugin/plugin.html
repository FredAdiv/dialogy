<!DOCTYPE html>
<html >
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
      <title>dialogy.plugin.plugin</title>
    
      <link rel="stylesheet" href="../../../_static/pygments.css">
      <link rel="stylesheet" href="../../../_static/theme.css">
      <link rel="stylesheet" href="../../../_static/sphinx_press_theme.css">
      
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>

      <!-- sphinx script_files -->
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>

      
      <script src="../../../_static/theme-vendors.js"></script>
      <script src="../../../_static/theme.js" defer></script>
    
  <link rel="index" title="Index" href="../../../genindex.html" />
  <link rel="search" title="Search" href="../../../search.html" /> 
  </head>

  <body>
    <div id="app" class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../../../index.html" class="home-link">
    
      <span class="site-name">dialogy</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Quick search</span>
    <div class="searchformwrapper">
      <form class="search" action="../../../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Search" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../../source/modules.html#dialogy">dialogy</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 "><a href="../../../source/dialogy.html" class="reference internal ">dialogy package</a>

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
    
      <li><a href="../../index.html">Module code</a> &raquo;</li>
    
    <li>dialogy.plugin.plugin</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main">
            
  <h1>Source code for dialogy.plugin.plugin</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;
.. _plugin:

Module provides access to an abstract plugin class.

We will summarize a few key points for creating plugins:

-   Don&#39;t interact with the workflow directly, use functions to access and mutate.
-   The convention for workflow access is `access(workflow)`.
-   The convention for workflow modification is `mutate(workflow, value)`.
-   Plugin names must end with Plugin for classes and _plugin for functions.

examples:
- Sentence2VecPlugin
- words2num_plugin
- RuleSlotFilerPlugin
- VotePlugin
&quot;&quot;&quot;
from typing import Any, Callable, Optional

from dialogy.types.plugin import PluginFn
from dialogy.utils.logger import change_log_level


<div class="viewcode-block" id="Plugin"><a class="viewcode-back" href="../../../source/dialogy.plugin.html#dialogy.plugin.plugin.Plugin">[docs]</a>class Plugin:
    &quot;&quot;&quot;
    A :ref:`Plugin &lt;plugin&gt;` instance interacts with a :ref:`workflow&lt;workflow&gt;`. A :ref:`workflow&lt;workflow&gt;` expects
    a set of plugins to be inserted into different stages: pre and post processing.
    A plugin can be conveniently written being unaware of the structure of any :ref:`Workflow &lt;workflow&gt;`
    by expecting `access` and `mutate` functions.

    **Dynamic Inputs**

    An :code:`access` method helps a :ref:`Plugin &lt;plugin&gt;` to require dynamic inputs from the :ref:`workflow&lt;workflow&gt;`
    while a :code:`mutate` method offers a :ref:`Plugin &lt;plugin&gt;` to update the processed output and place them as per
    expectations of the :ref:`workflow&lt;workflow&gt;` implementer&#39;s design.

    **Static Inputs**

    In case there are static inputs that won&#39;t change at runtime, these can be pre-loaded into the
    :ref:`Plugin &lt;plugin&gt;` by extending it.

    An example for this is:

    .. code-block:: python
        :linenos:
        :emphasize-lines: 14, 20

        class CustomPlugin(Plugin):
            def __init__(
                self,
                access: Optional[PluginFn],
                mutate: Optional[PluginFn]
            ) -&gt; None:
                \&quot;&quot;&quot;
                The `.load_corpus()` method reads some corpus.
                This is useful since we expect to read this
                just once and use it throughout the runtime.
                \&quot;&quot;&quot;
                self.access = access
                self.mutate = mutate
                self.corpus = None
                self.load_corpus()

            def load_corpus(corpus_dir: str, file_path: str) -&gt; None:
                corpus_file = os.path.join(corpus, file_path)
                with open(corpus_file, &quot;r&quot;) as handle:
                    self.corpus = handle.read().splitlines()

    We ship a few :ref:`Plugin &lt;plugin&gt;` with Dialogy, namely:

    1. :ref:`DucklingParser &lt;duckling_parser&gt;` (pre-processing)
    2. :ref:`merge_asr_output_plugin &lt;merge_asr_output_plugin&gt;` (pre-processing)
    3. :ref:`RuleBasedSlotFillerPlugin &lt;rule_slot_filler&gt;` (post-processing)
    4. :ref:`VotePlugin &lt;vote_plugin&gt;` (post-processing)
    &quot;&quot;&quot;

    def __init__(
        self,
        access: Optional[PluginFn],
        mutate: Optional[PluginFn],
        debug: bool = False,
    ) -&gt; None:
        self.access = access
        self.mutate = mutate
        self.debug = debug

    def __call__(self) -&gt; PluginFn:
        &quot;&quot;&quot;
        Build a plugin.

        This method returns a function. Since any functionality can be built into a plugin by
        extending the `Plugin` class but they are expected to work uniformly within a `workflow`,
        all plugins must have a standard API. The `__call__` method exists just for this abstraction.

        A plugin can be designed to do anything, while the `workflow` will expect all plugins
        to have a `__call__()` method.
        &quot;&quot;&quot;
        ...</div>
</pre></div>

          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; Copyright .
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a>.
</div>
            </div>
          </div>
      </page>
    </div>
    
    
  </body>
</html>